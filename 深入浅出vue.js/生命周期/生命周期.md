Vue.js的生命周期可分为：初始化阶段、模板编译阶段、挂载阶段、卸载阶段  
## 初始化阶段
new Vue()到created之间的阶段叫作初始化阶段，这个阶段主要是是初始化一些属性、事件和响应式数据，如：props、data、watch、methods、provide、inject等  
## 模板编译阶段
在created钩子函数与beforeMount钩子函数之间的阶段  
这个阶段就是将模板编译渲染为渲染函数，只存在于完整版之中，运行时版本，可以vue-loader和vueify做预编译，因此不存在模板编译阶段
## 挂载阶段
beforeMount到mounted之间的阶段，将模板渲染到指定的DOM元素中，在挂载的过程中，vue.js就会开启Watcher来持续追踪依赖的变化；在已挂载状态下，仍然会持续追踪状态的变化，当数据（状态）发生变化是，Watcher会通知虚拟dom重新渲染试图，并且在渲染视图前触发beforeUpdate钩子函数，渲染完毕后悔触发updated钩子函数  
## 卸载阶段
应用调用vm.$destroy方法后，Vue.js的生命周期会进入卸载阶段，这个阶段实例会将自身从父组件中删除，取消实例上的所有依赖追踪，移除所有的事件监听器  
## 从源码角度看生命周期  
new Vue()之后，会调用实例方法 this._init(options)来执行生命周期的初始化流程，也就是说，生命周期的初始化流程是在this_init中实现的  
````js
Vue.prototype._init = function (options){
    vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
    )

    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm,'beforeCreate')

    initInjections(vm) // 在data/props前初始化inject
    initState(vm)
    initProvide(vm)  //  在data/props后初始化provide
    callHook(vm,'created')

    // 如果用户在实例化Vue.js时传递了el选项，则自动开启模板编译阶段与挂载阶段
    // 如果没有传递el选项，则不进去下一个生命周期阶段（mounted)，而需要用户手动执行vm.$mount方法来开启模板编译阶段与挂载阶段
    if(vm.$options.el){
        vm.$mount(vm.$options.el)
    }
}
````
### callHook函数的内部原理  
作用就是触发用户设置的生命周期钩子，这些钩子会在执行new Vue()时，通过options参数传递给Vue.js，比如vm.$options.created就能获得created钩子函数  
值得注意的是，Vue.js在合并options的过程租户，会利用key获取函数，判断函数的名字是否是设置的钩子名字，然后将它转换成数组  
也就是说，**vm.$options.created获得是一个数组**
````js
console.log(vm.$options.created)  // [fn]
````
**为什么这样做？**  
与Vue.mixin有关，Vue.mixin方法可以将选项写入vue实例的options中，Vue.mixin 和 用户在实例化Vue.js时，如果设置的是同一个生命周期钩子，那么在触发生命周期时，需要同时触发这两个函数，所以保存在数组中  
````js
// 那callHook的原理就是遍历hook对应保存的数组，挨个触发
export function callHook(vm,hook){
    const handlers = vm.$options[hook]
    if(handlers){
        for(let i = 0; i < handlers.length; i++){
            try {
                handlers[i].call(vm)
            } catch(e) {
              handlerError(e,vm,`${hook}hook`)
            }
        }
    }
}
````
### errorCaptured与错误处理  
errorCaptured钩子函数就是用来捕获来自子孙组件的错误，3个参数：错误对象、发生错误的组件实例以及包含错误来源信息的字符串，钩子函数可以返回false，阻止该错误继续向上传播  
重点学习下代码设计，规则如下:
* 如果全局的config.errorHandler被定义了，那么所有错误都会发送给它  
* 过于一个组件继承的链路或其父级从属链路中存在多个errorCaptured钩子，则它们将会被相同的错误逐个唤起
* 如果errorCaptured钩子函数自身抛出了一个错误，那么这个新错误和原本捕获到的错误都会发送给全局的config.errorHandler
* 一个errorCaptured钩子函数能够返回false来阻止错误继续向上传播，本质上就是说“这个错误被搞定了”，就会阻止继续唤起链路上errorCaptured钩子函数和全局config.errorHandler  
````js
export function handleError(err, vm, info){
   if(vm){
       let cur = vm
       while((cur = cur.$parent)){
           if(hooks){
               for(let i=0; i < hooks.length; i++){
                   try{
                     // 程序的巧妙之处：钩子函数返回值若是false，则停止程序继续执行，也就不会继续沿着继承链路向上触发，而全局处理的函数代码被放在后面，所以最后globalHandleError也不会执行
                     const capture =  hooks[i].call(cur,err,vm,info) === false
                     if(capture) return
                   }catch(e){
                     globalHandleError(e,cur,'errorCaptured hook')
                   } 
               }
           }
       }
   }
   globalHandleError(err,vm,info)
}

function globalHandleError(err,vm,info){
   if(config.errorHandler){
       try {
           return config.errorHandler.call(null,err,vm,info)
       } catch(e) {
           logError(e)
       }
   }
   logError(err)
}
function logError(err){
    console.error(err)
}
````

