## 解析器
````html
<div>
   <p>{{ name }}</p>
</div>
````
解析器解析成AST之后的样子
````js
{
    tag: "div",
    type: 1,
    staticRoot: false,
    static: false,
    plain: true,
    parent: undefined,
    attrsList: [],
    attrsMap: {},
    children:[
        {
            tag: "p",
            type: 1,
            staticRoot: false,
            static: false,
            plain: true,
            parent: { tag:"div",...},
            attrsList: [],
            attrsMap: {},
            children:[{
                type:2,
                text: "{{ name }}",
                static: false,
                expression: "_s(name)"
            }]
        }
    ]
}
````
**其实也就是一个对象描述一个节点，当很多个独立的节点通过parent属性和children属性连在一起时，就变成了一个树**
### 解析器内部运行原理
解析器内部也分了好几个子解析器，比如HTML解析器、文本解析器以及过滤器解析器，核心HTML解析器在解析html的过程中会不断触发各种钩子函数，这些钩子函数包括开始标签钩子函数、结束钩子函数、文本钩子函数以及注释钩子函数
````js
// 伪代码
parseHTML(template,{
    start(tag,attrs,unary){
        // 每当解析到标签的开始位置时，触发该函数
    },
    end(){
        // 每当解析到标签的结束位置时，触发该函数
    },
    chars(text){
        // 每当解析到文本时，触发该函数
    },
    comment(text){
        // 每当解析到注释时，触发该函数
    }
})
````
````js
<div><p>qgq</p></div>
````
当上面这个模版被HTML解析器时，所触发的钩子函数依次是：start、start、chars、end和end  
钩子函数start有三个参数，分别是tag、attrs和unary，它们分别说明标签名、标签的属性以及是否是自闭合标签  
````js
function createASTElement(tag,attrs,parent){
    return {
        type: 1,
        tag,
        attrsList: attrs,
        parent,
        children: [],
    }
}

parseHTML(template,{
    start(tag,attrs,unary){
        let element = createASTElement(tag,attrs,currentParent)
    },
    chars(text){
        let element = { type:3, text }
    },
    comment(text){
        let element = { type:3, text, isComment: true }
    }
})
````
节点之间是有父子层级关系的，描述对象用parent和children连接，在模版没有被解析成节点对象之前，**我们通过维护一个栈，逐步找到这个父子关系，每当遇到开始标签，触发start钩子，就把当前构建的节点推入栈中；每当遇到结束标签，触发end钩子，就从栈中弹出一个节点**