## 变化侦测
数据模型仅仅是普通的js对象，修改数据，侦测数据的变化，更新视图  
**Vue对于Object和Array的变化侦测是采用不同的处理方式**
## Object的变化侦测
vue.js会自动通过状态生成DOM，并且在页面上显示，这个过程即是渲染  
vue.js2.0引入虚拟DOM, 一个状态所绑定的依赖**粒度**不再是具体的DOM节点，而是一个**组件**，状态变化会通知到组件，组件内部再使用虚拟DOM进行比对
### 如何追踪变化？Object.defineProperty(vue3.0使用Proxy)
````js
function defineReactive(data,key,val){
  Object.defineProperty(data,key,{
      enumerable:true,
      configurable: true,
      get: function(){
          return val
      },
      set: function(newVal){
          if(val === newVal){
              return
          }
          val = newVal
      }
  })
}
````
### 如何收集依赖？
````html
<template>
   <p>{{ name }}</p>
</template>
````
vue2.0,模板使用数据等同于组件使用数据  
>收集依赖 就是把用得到数据name的地方收集起来，等属性发生变化，把收集好的依赖循环触发一遍
### 依赖收集在哪儿？
getter中收集依赖，那么到底把依赖收集到哪里去了呢？ **dep数组**
````js
// Dep类专门用来帮助我们管理依赖，发布订阅模式，使用这个类可以收集依赖、删除依赖、向依赖发送通知
export default class Dep{
    constructor(){
        this.subs = []
    }

    addSub(sub){
        this.subs.push(sub)
    }

    removeSub(sub){
        remove(this.subs,sub)
    }
    
    depend(){
        // 假设依赖是一个函数，保存在window.target上
        if(window.target){
            this.addSub(window.target)
        }
    }
    
    notify(){
        const subs = this.subs.slice()
        for(let i=0;i<subs.length;i++){
            subs[i].update()
        }
    }
}

function remove(arr,item){
    if(arr.length){
        const index = arr.indexOf(item)
        if(index >-1){
            return arr.splice(index,1)
        }
    }
}
````
````js
// 改造一下defineReactive函数
function defineReactive(data,key,val){
    let dep = new Dep()
    Object.defineProperty(data,key,{
      enumerable:true,
      configurable: true,
      get: function(){
          dep.depend()
          return val
      },
      set: function(newVal){
          if(val === newVal){
              return
          }
          val = newVal
          dep.notify()
      }
  })
}
````
