## 函数式
总结来说，函数式编程在前端就体现在**三个特性**上，或者说是表现形式
* 闭包
* 柯里化
* 高阶函数
### 闭包
调用一个函数A，函数A内返回函数B，函数B会引用A中的变量，被引用的变量不会被GC回收
````js
function a(){
    var str = 'qgq'
    return function(){
        console.log(str)
    }
}
a()() // 调用
````
在函数式编程中，**闭包常被用来当作数据持久化的手段**
### 柯里化
接收多个参数的函数转换成只接收一个参数的函数，内部再返回函数接收剩余参数，柯里化的实现基于闭包
````js
var foo = function(p1){
    return function(p2){
        return  p1 + ' ' + p2
    }
}
foo('hello')('world') // hello world
````
柯里化把一个结果的返回，分成了多个步骤，把前一个步骤生成的结果先缓存起来，直到最后一步，**作用：区分了哪个参数在那个步骤做了什么事，利于debug和理解代码**  
示例代码中，调用foo('hello')，这个函数的功能是没有完成的，直到再调用才出结果  
函数式编程的每层嵌套，通常前面几层会做参数验证、数据准备、边界排查等前期工作，最后一层为核心代码
### 高阶函数
简单来说，就是把函数当作参数使用的函数，即在柯里化的基础上把参数限制为函数
````js
// 中学数学知识
f1(x) = (1-2x+3y+4z)(2x+1)
设 t = 1-2x+3y+4z
得 f2(t) = t(2x + 1)

/*
 f2接收了一个函数参数t,这里可认为t(2x+1)是返回的新函数，f2称之为高阶函数
*/
````
````js
function square(i){
    return i * i
}

function map(handeler,list){
    return list.map(handeler)
}

function currying(map,square){
    return function(arr){
        return map(square,arr)
    }
}

var mapSQ = currying(map,square);
mapSQ([1,2,3,4,5])  // [1,4,9,16,25]
````
### 函数式编程的作用
* 每一步都变成了显性调用，并且每一步产生的结果都会被缓存起来，下一步时机不成熟，可以暂缓调用，也可终止调用、数据回收
* 每一步因为都是主动调用，所以使用者很清楚函数调用到了哪一步，做了哪些事
* 函数负责完成功能，返回一个最终结果，只是做这一件事，**不会引用全局变量，需要什么变量就只通过参数传递过来，无论环境如何改变，传递相同的参数，就是相同的结果**